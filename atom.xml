<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cary&#39;s Blog</title>
  
  
  <link href="http://caryhuang.github.io/atom.xml" rel="self"/>
  
  <link href="http://caryhuang.github.io/"/>
  <updated>2021-10-01T21:17:07.010Z</updated>
  <id>http://caryhuang.github.io/</id>
  
  <author>
    <name>Cary Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PostgreSQL 14 Continuous archiving and Point In Time Recovery Tutorial</title>
    <link href="http://caryhuang.github.io/2021/10/01/Set-up-PostgreSQL-Continuous-archiving-and-Perform-Point-In-Time-Recovery/"/>
    <id>http://caryhuang.github.io/2021/10/01/Set-up-PostgreSQL-Continuous-archiving-and-Perform-Point-In-Time-Recovery/</id>
    <published>2021-10-01T18:33:13.000Z</published>
    <updated>2021-10-01T21:17:07.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Recently I have been practicing the internals of PostgreSQL continuous archiving and the point in time recovery features that are required for my current development work. Today I would like to demonstrate these important features with the recently released PostgreSQL 14 on Ubuntu 18.04.</p><h3 id="2-Write-Ahead-Log"><a href="#2-Write-Ahead-Log" class="headerlink" title="2. Write Ahead Log?"></a>2. Write Ahead Log?</h3><p>Before going into the details of continuous archiving, it is important to understand the concept of Write Ahead Log (WAL). WAL files are generated by PG that contains all of the operations done on the database since the beginning. Operations such as <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>VACUUM</code> …etc are captured in WAL files. Having these WAL files, it is possible to recreate the database simply by <code>replaying</code> them, allowing an user to recover the database to a certain state in case of fault. This is the basis of continuous archiving and point in time recovery.</p><h3 id="3-What-is-Continuous-Archiving"><a href="#3-What-is-Continuous-Archiving" class="headerlink" title="3. What is Continuous Archiving?"></a>3. What is Continuous Archiving?</h3><p>The generated WAL files are normally stored in the <code>pg_wal</code> directory within the PG database cluster, but they will not grow forever. The configuration parameters, <code>max_wal_size</code> and <code>min_wal_size</code> control how many WAL files can be kept in <code>pg_wal</code> directory. The checkpointer process will periodically purge the old WAL files, leaving only recent ones.</p><p>So, it is important to set up continuous archiving so all these WAL files can be <code>archived</code> to somewhere else outside of PG cluster. So, when you need all the old WAL files for recovery, PG can restore them from the archive.</p><p>To enable WAL archiving and restoring, set these parameters in postgresql.conf:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">archive_mode &#x3D; on</span><br><span class="line">archive_command &#x3D; &#39;cp %p &#x2F;path&#x2F;to&#x2F;archive&#x2F;%f&#39;</span><br><span class="line">restore_command &#x3D; &#39;cp &#x2F;path&#x2F;to&#x2F;archive&#x2F;%f %p&#39;</span><br></pre></td></tr></table></figure><p>where you should replace <code>/path/to/archive</code> with your own archive path on your system. %p and %f will be swapped with <code>path to WAL segment</code> and <code>WAL segment name</code> to complete the command.</p><p>When a WAL segment is ready to be archived, PG will create a signal file in <code>pg_wal/archive_status</code> to indicate a particular WAL segment is ready for archive. </p><p>In the example below, the segment <code>00000001000000000000000E</code> is ready for archive, indicated by the postfix <code>.ready</code> while all of the previous segments have been successfully archived and therefore indicated by the <code>.done</code> postfix.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls pgtest&#x2F;pg_wal&#x2F;archive_status&#x2F;</span><br><span class="line">000000010000000000000002.done  000000010000000000000005.done  00000001000000000000000A.done  00000001000000000000000E.ready</span><br><span class="line">000000010000000000000003.done  000000010000000000000007.done  00000001000000000000000B.done</span><br><span class="line">000000010000000000000004.done  000000010000000000000008.done  00000001000000000000000D.done</span><br></pre></td></tr></table></figure><p>The PG’s archiver process will then be waken up to perform the archive by running the <code>archive_command</code> configured.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ps -ef | grep postgres</span><br><span class="line"></span><br><span class="line">caryh     1487     1  0 11:10 ?        00:00:00 postgres -D &#x2F;home&#x2F;caryh&#x2F;pgtest</span><br><span class="line">caryh     1510  1487  0 11:10 ?        00:00:00 postgres: checkpointer</span><br><span class="line">caryh     1511  1487  0 11:10 ?        00:00:00 postgres: background writer</span><br><span class="line">caryh     1512  1487  0 11:10 ?        00:00:00 postgres: walwriter</span><br><span class="line">caryh     1516  1487  0 11:10 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">caryh     1520  1487  0 11:10 ?        00:00:00 postgres: archiver   archiving 00000001000000000000000E</span><br><span class="line">caryh     1521  1487  0 11:10 ?        00:00:00 postgres: stats collector</span><br><span class="line">caryh     1522  1487  0 11:10 ?        00:00:00 postgres: logical replication launcher</span><br></pre></td></tr></table></figure><p>Note that the archiver (PID=1520) also shows its progress on the <code>ps</code> display.</p><p>When done successfully, the signal file in <code>pg_wal/archive_status</code> will be updated to <code>.done</code> postfix.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls pgtest&#x2F;pg_wal&#x2F;archive_status&#x2F;</span><br><span class="line">000000010000000000000002.done  000000010000000000000005.done  00000001000000000000000A.done  00000001000000000000000E.done</span><br><span class="line">000000010000000000000003.done  000000010000000000000007.done  00000001000000000000000B.done</span><br><span class="line">000000010000000000000004.done  000000010000000000000008.done  00000001000000000000000D.done</span><br></pre></td></tr></table></figure><p>In the next checkpoint, these <code>.done</code> files will be removed so these status files will not be continuously growing as well.</p><h3 id="4-What-is-Point-In-Time-Recovery-PITR"><a href="#4-What-is-Point-In-Time-Recovery-PITR" class="headerlink" title="4. What is Point In Time Recovery (PITR)?"></a>4. What is Point In Time Recovery (PITR)?</h3><p>Having all of the WAL segments backed up in a separate archive, we gained the ability to recovery the database up yo a certain point in time in the past or completely recover the whole database. This depends on your use case, if you made a major mistake and need to start again from a point of time in the past, you can have PG to recover to that particular time during recovery mode and continue the database operation from that point. This is also referred to as <code>switching  to a new time line ID</code> and we will discuss this more in the next blog.</p><p>Let’s continue from the above example (which already has 1 million rows of data) and do a point in time recovery.</p><ol><li><p>Make a basebackup of the current database, we can use <code>pg_basebackup</code> to achieve this</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pg_basebackup -U caryh -h 127.0.0.1 --progress -D pgtest-back</span><br></pre></td></tr></table></figure></li><li><p>back to the database and continue inserting some more data, use <code>pg_switch_wal</code> to immediate write out the WAL segment and obtain a <code>LSN</code>. LSN stands for Log Sequence Number, and it logically represent a WAL entry within a WAL segment. Refer to documentation <a href="https://www.postgresql.org/docs/current/datatype-pg-lsn.html">here</a> for more information.</p></li></ol><p>After obtaining the LSN, we again insert some more rows of data. </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into test values(generate_series(1,1000000), &#39;asdas&#39;);</span><br><span class="line">insert into test values(generate_series(1,1000000), &#39;asdas&#39;);</span><br><span class="line"></span><br><span class="line">pg_switch_wal();</span><br><span class="line"> pg_switch_wal</span><br><span class="line">---------------</span><br><span class="line"> 0&#x2F;13DAC308</span><br><span class="line"></span><br><span class="line">insert into test values(generate_series(1,1000000), &#39;asdas&#39;);</span><br><span class="line">insert into test values(generate_series(1,1000000), &#39;asdas&#39;);</span><br></pre></td></tr></table></figure><p>So, in total, this table <code>test</code> should have 5 million rows of data, because it started with 1 million and we just inserted 4 million more in the example above.</p><p>The WAL location indicated by LSN <code>0/13DAC308</code> indicated a time when the database only contains 3 million rows, and this is the <code>point of time</code> that we would like to recover up to in our example.</p><ol start="3"><li><p>Stop the database server</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pg_ctl -D pgtest stop</span><br></pre></td></tr></table></figure></li><li><p>Wipe out everything in this database <code>pgtest</code></p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm -rf pgtest&#x2F;</span><br></pre></td></tr></table></figure><p>I know it sounds crazy, but remember, we made a basebackup back in (1.) + all the WAL segments in the archive, so technically we still have everything.</p><ol start="5"><li>Copy everything from our basebackup back to <code>pgtest</code></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r pgtest-back&#x2F;* pgtest&#x2F;</span><br></pre></td></tr></table></figure><ol start="6"><li>Edit pgtest/postgresql.conf and set your recover target</li></ol><p>Since we are using LSN as our target, we can simply put the LSN we captured to <code>recovery_target_lsn</code> configuration</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">recovery_target_lsn &#x3D; &#39;0&#x2F;13DAC308&#39;</span><br></pre></td></tr></table></figure><p>PG also supports other ways to define recovery target, based on timestamp, name or xid. Refer to this <a href="https://www.postgresql.org/docs/11/recovery-target-settings.html">documentation</a> for other options.</p><ol start="7"><li>Signal the database to run in recovery mode by creating a <code>recovery.signal</code> file under the <code>pgtest</code> cluster</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$touch pgtest&#x2F;recovery.signal</span><br></pre></td></tr></table></figure><ol start="8"><li>Start the server<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$pg_ctl -D pgtest start</span><br></pre></td></tr></table></figure></li></ol><p>the server will now start in recovery mode and it will restore WAL files from the archive and perform the recover. You may log in with <code>psql</code> and check that the database should contain also 3 million rows instead of 5. </p><p>You may notice that even though the database has been recovered to a point of time in the past, you will encounter a <code>database in recovery</code> or <code>read only database</code> error if you intend to insert additional data. This is because we are still in the <code>recovery mode</code> but is currently <code>paused</code>.</p><p>This is configured by the <code>recovery_target_action</code> option, which defaults to <code>pause</code>. This is actually intended, to allow you to have a moment to check your database and confirm that it is indeed the database state that you would like to recover to. If this is wrong, you can simply shutdown the database and reconfigure the <code>recovery_target_lsn</code> until you reach a desired state of database.</p><ol start="9"><li>Exit the recovery mode<br>Once you are confirm the database is recovered correctly, you can exit the recovery mode by this psql command:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select pg_wal_replay_resume();</span><br></pre></td></tr></table></figure></li></ol><p>This command will end the recovery mode and you should be able to insert additional data to the database. The <code>recovery.signal</code> file will be removed, and the future WAL segments will have a new timeline ID.</p><p>Timeline ID is also an important aspect of the recovery and we will discuss more on timeline ID in my next post.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h3&gt;&lt;p&gt;Recently I have been</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="http://caryhuang.github.io/categories/PostgreSQL/"/>
    
    
    <category term="postgresql" scheme="http://caryhuang.github.io/tags/postgresql/"/>
    
    <category term="pitr" scheme="http://caryhuang.github.io/tags/pitr/"/>
    
    <category term="recovery" scheme="http://caryhuang.github.io/tags/recovery/"/>
    
  </entry>
  
</feed>
