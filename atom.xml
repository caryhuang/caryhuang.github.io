<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cary&#39;s Blog</title>
  
  
  <link href="http://caryhuang.github.io/atom.xml" rel="self"/>
  
  <link href="http://caryhuang.github.io/"/>
  <updated>2022-07-08T19:09:25.158Z</updated>
  <id>http://caryhuang.github.io/</id>
  
  <author>
    <name>Cary Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maintain a custom PG to PG Connection With libpq&#39;s COPY protocol</title>
    <link href="http://caryhuang.github.io/2022/07/08/Maintain-a-custom-PG-to-PG-Connection-With-libpq-s-COPY-protocol/"/>
    <id>http://caryhuang.github.io/2022/07/08/Maintain-a-custom-PG-to-PG-Connection-With-libpq-s-COPY-protocol/</id>
    <published>2022-07-08T16:45:40.000Z</published>
    <updated>2022-07-08T19:09:25.158Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Recently in my development work, a custom connection is required to be maintained between a PG backend on primary and another PG backends on standby nodes to communicate custom data in addition to the existing walsender/walreceiver connection that streams WAL data. Of course, I could just create a new standalone backend and maintain a socket connection myself to communicate custom data. Technically, It could work, but it also created several problems. the persistence, user security, data encryption of this custom connection all need to be handled as well. So, why not just use libpq to handle all of these for us? Today, in this blog, I will share my experience with using libpq COPY protocol to maintain a custom connection for custom data based on PG14.</p><h3 id="2-Create-new-routines-in-libpqwalreceiver-c"><a href="#2-Create-new-routines-in-libpqwalreceiver-c" class="headerlink" title="2. Create new routines in libpqwalreceiver.c"></a>2. Create new routines in libpqwalreceiver.c</h3><p>This file is located in <code>src/backend/replication/libpqwalreceiver</code> and is compiled as a shared library (.so) that contains routines related to libpq library that allows a PG backend to use libpq without having it compiled in the backend code. When a PG backend process needs to use libpq, it needs to load the shared library first using <code>load_file()</code> call. </p><p>My requirement is simple, the new routines I needed are <code>connect</code>, <code>send</code>, <code>recv</code>, similar to normal socket interactions. I do not have a <code>close</code> function defined here, because I would like the connection to be persisted as long as the primary and standby are running. When one of them exits, the connection will be automatically terminated once it has detected the peer has disconnected. </p><h3 id="3-The-Connect-Routine"><a href="#3-The-Connect-Routine" class="headerlink" title="3. The Connect Routine"></a>3. The Connect Routine</h3><p>Unlike the <code>libpqrcv_connect</code> routine for replication, my case is much simpler. I just need my standby node to connect to the primary node, so I can simply reuse standby’s <code>primary_conninfo</code> configuration parameter to connect. This will trigger the primary node to fork a new backend process to serve this connection. A code snipper could look like this:</p><p><img src="/images/connect.jpg" alt="connect"></p><p>I also set my libpq socket connection to use blocking socket and set <code>asyncStatus</code> to be <code>PGASYNC_COPY_BOTH</code> to indicate that I will be doing a bidirectional data communication </p><h3 id="4-The-Send-Routine"><a href="#4-The-Send-Routine" class="headerlink" title="4. The Send Routine"></a>4. The Send Routine</h3><p>My send routine is exactlt the same to the <code>libpqrcv_send</code> routine for replication. Both uses <code>PQputCopyData</code> to send streams of data out to the primary. Renamed it for consistency. Snippet below:</p><p><img src="/images/send.jpg" alt="send"></p><h3 id="5-The-Recv-Routine"><a href="#5-The-Recv-Routine" class="headerlink" title="5. The Recv Routine"></a>5. The Recv Routine</h3><p>Also, very similar to <code>libpqrcv_recv</code> routine for replication, it shares almost exactly the same code. Except that for my requirement, the connection needs to be a <code>synchronous</code> connection. This means that my standby will block while waiting for primary to respond. In order to make recv synchronous, I had to pass a <code>0</code> to the third argument of <code>PQgetCopyData</code>. So, if you are okay with <code>asynchronous</code> connection, this routine could look exactly the same as <code>libpqrcv_recv</code> as well.</p><p><img src="/images/recv.jpg" alt="recv"></p><h3 id="6-Having-Standby-to-Send-Out-Some-Custom-Data"><a href="#6-Having-Standby-to-Send-Out-Some-Custom-Data" class="headerlink" title="6. Having Standby to Send Out Some Custom Data"></a>6. Having Standby to Send Out Some Custom Data</h3><p>Now that we have the libpq wrapper routines made for our own purpose, we can then have the standby sends some custom data to the primary and waits for a response. Note that I am sending a letter ‘N’ followed by 3 example custom data, 100, 200, 300. Libpq COPY uses the letter <code>d</code> to indicate a COPY command, and what we are doing here is to <code>wrap</code> our own commands within the <code>d</code> command</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StringInfoData buf_blk_request;</span><br><span class="line">WalReceiverConn *wrconn;</span><br><span class="line">int len;</span><br><span class="line"></span><br><span class="line">load_file(&quot;libpqwalreceiver&quot;, false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wrconn &#x3D; netbuf_connect(&quot;dbname&#x3D;postgres  host&#x3D;127.0.0.1 port&#x3D;5550&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">initStringInfo(&amp;buf_blk_request);</span><br><span class="line">pq_sendbyte(&amp;buf_blk_request, &#39;N&#39;);</span><br><span class="line">pq_sendint32(&amp;buf_blk_request, 100);</span><br><span class="line">pq_sendint32(&amp;buf_blk_request, 200);</span><br><span class="line">pq_sendint32(&amp;buf_blk_request, 300);</span><br><span class="line">pq_flush();</span><br><span class="line"></span><br><span class="line">&#x2F;* Send it *&#x2F;</span><br><span class="line">netbuf_send(wrconn, buf_blk_request.data, buf_blk_request.len);</span><br><span class="line"></span><br><span class="line">&#x2F;* Read the data *&#x2F;</span><br><span class="line">len &#x3D; netbuf_recv(wrconn, &amp;tmp, &amp;fd);</span><br><span class="line">if (len &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Something was received from primary</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Having-Primary-to-Receive-the-Custom-Data"><a href="#7-Having-Primary-to-Receive-the-Custom-Data" class="headerlink" title="7. Having Primary to Receive the Custom Data"></a>7. Having Primary to Receive the Custom Data</h3><p>When we send something using the methods above, the primary’s postmaster’s main loop will receive the data and decide what to do. Because we are using COPY protocol, the first character is <code>d</code>, in which <code>src/backend/tcop/postgres.c</code> already has a handler for that. So we will need to add additional code under the <code>d</code> handler in <code>postgres.c</code> to receive and process the data sent by standby and provide a response if needed.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case &#39;d&#39;:&#x2F;* copy data *&#x2F;</span><br><span class="line">elog(DEBUG2, &quot;copy data request received&quot;);</span><br><span class="line">int op;</span><br><span class="line"></span><br><span class="line">op &#x3D; pq_getmsgbyte(&amp;input_message);</span><br><span class="line">if (op &#x3D;&#x3D; &#39;N&#39;)</span><br><span class="line">&#123;</span><br><span class="line">StringInfoData buf_blk_reply;</span><br><span class="line">int data1, data2, data3;</span><br><span class="line"></span><br><span class="line">&#x2F;* receive custom data here *&#x2F;</span><br><span class="line">data1 &#x3D; pq_getmsgint(&amp;input_message, 4);</span><br><span class="line">data2 &#x3D; pq_getmsgint(&amp;input_message, 4);</span><br><span class="line">data3 &#x3D; pq_getmsgint(&amp;input_message, 4);</span><br><span class="line">pq_getmsgend(&amp;input_message);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* send another custom data back to standby here *&#x2F;</span><br><span class="line">pq_beginmessage(&amp;buf_blk_reply, &#39;d&#39;);</span><br><span class="line">pq_sendint32(&amp;buf_blk_request, 400);</span><br><span class="line">pq_sendint32(&amp;buf_blk_request, 500);</span><br><span class="line">pq_sendint32(&amp;buf_blk_request, 600);</span><br><span class="line">pq_endmessage(&amp;buf_blk_reply);</span><br><span class="line">pq_flush();</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><h3 id="8-Summary"><a href="#8-Summary" class="headerlink" title="8. Summary"></a>8. Summary</h3><p>Based on libpq COPY, I have created a separate communication channel between a primary and standby node that can be used to communicate custom data similar to how you would normally handle a regular socket. All this is based on the COPY protocl that libpq already supports and within that protocol, we wrap our own data. In the above examples, when standby sends 100, 200, 300 to the primary, it is able to receive it and respond 400, 500, 600. This simple example can be expanded to support other things that you may need in your development. This way of using COPY for rown purpose may not be the cleaniest way, but it is what works for me.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h3&gt;&lt;p&gt;Recently in my devel</summary>
      
    
    
    
    
    <category term="Postgresql" scheme="http://caryhuang.github.io/tags/Postgresql/"/>
    
    <category term="libpq" scheme="http://caryhuang.github.io/tags/libpq/"/>
    
    <category term="copy" scheme="http://caryhuang.github.io/tags/copy/"/>
    
  </entry>
  
</feed>
