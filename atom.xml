<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cary&#39;s Blog</title>
  
  
  <link href="http://caryhuang.github.io/atom.xml" rel="self"/>
  
  <link href="http://caryhuang.github.io/"/>
  <updated>2021-12-10T22:28:47.137Z</updated>
  <id>http://caryhuang.github.io/</id>
  
  <author>
    <name>Cary Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A Look Inside PostgreSQL&#39;s Extended Query Protocol</title>
    <link href="http://caryhuang.github.io/2021/12/10/A-Look-Inside-PostgreSQL-s-Extended-Query-Protocol/"/>
    <id>http://caryhuang.github.io/2021/12/10/A-Look-Inside-PostgreSQL-s-Extended-Query-Protocol/</id>
    <published>2021-12-10T19:34:58.000Z</published>
    <updated>2021-12-10T22:28:47.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Few weeks ago, I was tasked to have a detailed look inside PostgreSQL’s extended query protocol and study its internal mechanisms for a project that depends on this particular feature. In this blog, I will explain how extended protocol works in my own words and how it differs from simple query.</p><h3 id="2-Simple-Query"><a href="#2-Simple-Query" class="headerlink" title="2. Simple Query"></a>2. Simple Query</h3><p>A client is able to initiate 2 type of queries against a PostgreSQL server, simple query or extended query. Simple query, as the name suggests, is very simple and straightforward to understand. When we launch the <code>psql</code> client tool to connect to a PostgreSQLs server, almost all of the SQL commands sent are considered as simple queries. This includes the use of <code>begin</code> and <code>commit</code> to enclose a transaction, having multiple SQL queries included in one big query separated by a semicolon, executing or defining a function and much more. </p><p>Simple query automatically follows the standard query processing routines, which consist of these stages:</p><ul><li>Parser</li><li>Analyzer</li><li>Rewriter</li><li>Planner</li><li>Executor</li></ul><p>Refer to this blog <a href="https://www.highgo.ca/2019/10/03/trace-query-processing-internals-with-debugger/">here</a> for detailed information about query processing.</p><p>The communication between the client and the server is also very straightforward. In case of DML operations such as INSERT, the client sends the query to the server for processing and the server responds a <code>CommandComplete</code> message such as <code>INSERT 0 1</code> followed by a <code>ReadyForQuery(IDLE)</code> message to indicate that the server has finished the query and is now idle. The client can send another query and it follows the same patter. </p><p>In case of a <code>SELECT</code> query, the server will send the row description followed by the actual row data satisfying the query until there is no more rows to return. In the end, the server sends a <code>ReadyForQuery(IDLE)</code> message to indicate that the server has finished the query and is now idle.</p><h3 id="3-Extended-Query"><a href="#3-Extended-Query" class="headerlink" title="3. Extended Query"></a>3. Extended Query</h3><p>Extended query is the other way for the client to complete a query excepts that it breaks down the standard query processing into different steps and <code>the client</code> is responsible to ensure these steps are followed and executed correctly. The client is able to control thses steps by sending the following wire protocol message types:</p><ul><li><p>‘P’ message (Parse)</p><ul><li><code>P</code> message takes a generalize query string with data values repalced with placeholders like <code>$1</code>, <code>$2</code>, which can be later substitued with real values in the Bind step.</li><li>This generalized query string will be parsed via these query processing routines: <code>Parser</code> -&gt; <code>Analyzer</code> -&gt; <code>Rewriter</code></li><li>At the end of a successful Parse, a <code>prepared statement</code> is produced, similar to SQL’s <code>PREPARE</code> clause</li><li>This <code>prepared statement</code> can be <code>named</code> or <code>unnammed</code> (more on this next).</li><li>This <code>prepared statement</code> is just a representation of the input query and it cannot be executed yet. </li></ul></li><li><p>‘B’ message (Bind)</p><ul><li><code>B</code> takes the <code>named</code> or <code>unnammed</code> <code>prepared statement</code> produced from the <code>P</code> message and replaces the placeholders ($1, $2) with the user-supplied values.</li><li>After the values are bound to the <code>prepared statement</code>, we basically have a completed query and it will then be fed into the <code>planner</code> stage to produce the most optimized query plan for the query.</li><li>At the end of a successful planning, a <code>portal</code> is produced. </li><li>This <code>portal</code> can also be <code>named</code> or <code>unnammed</code> (more on this next)</li><li>A portal is basically an object that represents how to execute a particular query</li></ul></li><li><p>‘E’ message (Execute)</p><ul><li><code>E</code> takes the <code>named</code> or <code>unnamed</code> <code>portal</code> produced from the <code>B</code> message and actuallly launch the <code>executor</code> to execute the query (or portal).</li><li>resultant rows are produced (if any) and returns to the client</li></ul></li><li><p>‘S’ message (Sync)</p><ul><li>The client has to send a <code>S</code> message to the server to indicate the end of the extended query. </li><li>This message causes the server to end the current transaction and sends <code>ReadyForQuery(IDLE)</code> message back to client.</li></ul></li></ul><p>What is the purpose of separating a simple query into multiple steps? One major benefit of using the extended query is that it can save a lot of unnecessary parsing of the same query structure. Instead, we can have the common strucuture parsed only once and then bind and execute with different values multiple times.</p><h3 id="4-Named-and-Unnamed-Prepared-Statement-and-Portal"><a href="#4-Named-and-Unnamed-Prepared-Statement-and-Portal" class="headerlink" title="4. Named and Unnamed Prepared Statement and Portal"></a>4. Named and Unnamed Prepared Statement and Portal</h3><p>In previous section we mentioned that a prepared statement and protal can be either <code>named</code> or <code>unnamed</code> during the extended query protocol. What does it mean and what is the significance? </p><p>The general rule is that PostgreSQL server can only keep one unnamed prepared statement or portal. Requests containing unnamed prepared statemnt or portal will replace the existing ones. </p><p>With named prepared statement or portal, the server will respectively remember them based on the names given and client is able to invoke them any time or specifically destroyed by sending a Close message. </p><p>So, it is possible for a client to create multiple prepared statements within a transaction, each having different prepared statement names, and then bind values for them all at the same time by giving them different portal names. Eventually, the client chooses which portal to be executed.</p><p>More importantly, named prepared statement’s life time lasts for the entire TCP session unless explicitly destroyed; named portal lasts only until the end of transaction or when it is executed or explicitly destroyed.</p><p>But, does it make client implementation more complicated if extended query is used?</p><p>Yes, but client has a choice to complicate things or not</p><p>Taking libpq for example, when extended query is used, it requires the client application to provide a prepared statement name to construct the <code>P</code> (Parse) message, but does not require the client application to provide portal name to construct the <code>B</code> (Bind) message. This means that with libpq, we can send <code>P</code> message multiple times with different prepared statement names, but with <code>B</code> message, it forces to use unnamed portal name, so we always have one portal to execute. This avoids the case with multiple portal names in the client side to manage. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h3&gt;&lt;p&gt;Few weeks ago, I was</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="http://caryhuang.github.io/categories/PostgreSQL/"/>
    
    
    <category term="postgresql" scheme="http://caryhuang.github.io/tags/postgresql/"/>
    
    <category term="extended query" scheme="http://caryhuang.github.io/tags/extended-query/"/>
    
    <category term="wire protocol" scheme="http://caryhuang.github.io/tags/wire-protocol/"/>
    
  </entry>
  
</feed>
