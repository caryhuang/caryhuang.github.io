<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cary&#39;s Blog</title>
  
  
  <link href="http://caryhuang.github.io/atom.xml" rel="self"/>
  
  <link href="http://caryhuang.github.io/"/>
  <updated>2021-09-03T20:49:56.864Z</updated>
  <id>http://caryhuang.github.io/</id>
  
  <author>
    <name>Cary Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>How to Implement Foreign Scan With FDW Interface API</title>
    <link href="http://caryhuang.github.io/2021/09/03/How-to-Implement-Foreign-Scan-With-FDW-Interface-API/"/>
    <id>http://caryhuang.github.io/2021/09/03/How-to-Implement-Foreign-Scan-With-FDW-Interface-API/</id>
    <published>2021-09-03T16:47:45.000Z</published>
    <updated>2021-09-03T20:49:56.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Recently I have been tasked to familiarize myself with the Foreign Data Wrapper (FDW) interface API to build a new FDW capable of doing vertical / columnar sharding, meaning that the FDW is capable of collecting column information from multiple sources and combine them together as a result query. I will document and blog about the vertical sharding in later posts. Now, in this blog, I would like to share some of the key findings and understanding of FDW interface related to foreign scan.</p><h3 id="2-Scan-related-API-Routines"><a href="#2-Scan-related-API-Routines" class="headerlink" title="2. Scan-related API Routines"></a>2. Scan-related API Routines</h3><p>FDW foreign scan API routines have some similarities to the table access method API’s sequential scan routines. You can learn more about it in the blog post <a href="https://www.highgo.ca/2021/01/15/how-postgresql-executes-sequential-scans-with-the-help-of-table-access-methods-apis/">here</a>. Most noticeable difference is that the FDW routines require us to take part during the planning stage, so we have to come out with a foreign plan for the exectuor so it knows what and how to perform the foreign scan.</p><p>In order to complete a foreign scan, the following FDW routines are invoked in order:</p><ul><li>IsForeignScanParallelSafe</li><li>GetForeignRelSize</li><li>GetForeignPaths</li><li>GetForeignPlan</li><li>BeginForeignScan</li><li>IterateForeignScan</li><li>…</li><li>IterateForeignScan</li><li>EndForeignScan</li></ul><h4 id="2-1-IsForeignScanParallelSafe"><a href="#2-1-IsForeignScanParallelSafe" class="headerlink" title="2.1 IsForeignScanParallelSafe"></a>2.1 IsForeignScanParallelSafe</h4><p>In this routine, you have to tell PG whether or not the foreign scan can support parallel Scan by returning true to indicate it is supported, or false otherwise. Parallel scan is invokved by the planner when a scan query involves retrieving a large amount of data. Depending on the foreign server and your implementation, you have to decide whether or not parallel scan is supported.</p><h4 id="2-2-GetForeignRelSize"><a href="#2-2-GetForeignRelSize" class="headerlink" title="2.2 GetForeignRelSize"></a>2.2 GetForeignRelSize</h4><p>Similar to the table access method’s <code>relation_estimate_size()</code> API, this routine requires you to provide an estimate of the amount of tuples/rows would be involved during this round of scanning. This information is very important because it directly affects the planner’s decision to execute the query. For example, if you say foreign relation has 1 million tuples to be fetched, then the planner is most likely to use parallel scan to complete the scan for performance reasons if you answer “true” in the <code>IsForeignScanParallelSafe()</code> function call.</p><h4 id="2-3-GetForeignPaths"><a href="#2-3-GetForeignPaths" class="headerlink" title="2.3 GetForeignPaths"></a>2.3 GetForeignPaths</h4><p>In this routine, we are required to provide a list of possible paths to complete the required foreign scan. Paths simply means ways to execute. For example, you can complete a foreign scan by doing a sequential scan by fetching 1 tuple at a time, or you can complete the same scan using index to look-up a target tuple if the table has an index defined and user gives specific <code>WHERE</code> clause to pinpoint a tuple. If user provides a <code>WHERE</code> clause to filter the result, you also have an option to estimate whether the <code>WHERE</code> can be executed by the foreign server or by the local server as it fetches a tuple.</p><p>All these are possible <code>pathnodes</code> are required by the planner to decide on the optimal path to execute the scan. Each <code>pathnode</code> requires you to provide the <code>startup cost</code>, <code>total cost</code>, <code>number of rows</code> and <code>path keys</code> if any. The official documentation suggests that you should use <code>add_path</code> and <code>create_foreignscan_path</code> routines to prepare a list of path nodes.</p><h4 id="2-4-GetForeignPlan"><a href="#2-4-GetForeignPlan" class="headerlink" title="2.4 GetForeignPlan"></a>2.4 GetForeignPlan</h4><p>Having provided all the possible <code>pathnodes</code>, planner will pick one that is the most optimal and pass that <code>pathnode</code> to this routine and ask you to make a foreign scan plan for the executor. This is a very important function because whatever plan that we provide here directly affects how the executor is going to function, so be cautious here.</p><p>In this function, the planner will give you everything about the query such as the target attribute list and the restricting clauses (<code>WHERE</code> clauses) and also the information about the foreign relation, such as its OID, and each column’s data types. Official PostgreSQL documentation suggests using <code>make_foreignscan()</code> routine with the desired arguments to create the foreign plan.</p><p>In here, you also will have an option to <code>push down</code> the restricting clauses or not. In other words, you can choose to send all the <code>WHERE</code> clauses to the foreign server to process if it can support it. This results in much less data communication. You can also choose having all the <code>WHERE</code> clauses to be processed locally, but this requires the FDW to fetch every single row from the foreign server, resulting in more data communication. This decision is controlled by the <code>List *qpqual</code> argument to the <code>make_foreignscan()</code> function. If this list contains the list of your restricting clauses, the local server will perform the <code>WHERE</code> evaluation locally; if this list is empty, then the local server assumes the FDW will do the <code>WHERE</code> evaluation on the foreign server</p><h4 id="2-5-BeginForeignScan"><a href="#2-5-BeginForeignScan" class="headerlink" title="2.5 BeginForeignScan"></a>2.5 BeginForeignScan</h4><p>This routine will be called before starting the foreign scan, giving you a chance to allocate all the necessary control information required for your foreign scan. You can define your own control information, for example, cursor location, remote connection structure, current offset…etc. and store in <code>node-&gt;fdw_state</code> and it will be passed down to the <code>IterateForeignScan</code> as the scan is begin completed.</p><h4 id="2-6-IterateForeignScan"><a href="#2-6-IterateForeignScan" class="headerlink" title="2.6 IterateForeignScan"></a>2.6 IterateForeignScan</h4><p>This is the main routine to perform the actual scan. You need to put the proper logic here depending on your use case to fetch one or more rows from the foreign server. When you have the row data, you will need to convert that to a <code>TupleTableSlot</code> strucutre in which the PG internals can understand. We normally use <code>ExecStoreHeapTuple()</code> routine to convert a HeapTuple into a <code>TupleTableSlot</code>. This routine will be continuously called by the PG executor as long as you still have data to fetch and it will only stop once you return an empty <code>TupleTableSlot</code>.</p><h4 id="2-7-EndForeignScan"><a href="#2-7-EndForeignScan" class="headerlink" title="2.7 EndForeignScan"></a>2.7 EndForeignScan</h4><p>This routine will be called at the end of foreign scan, giving you the opportunity to clean up the control information allocated in <code>BeginForeignScan()</code>. This marks the end of foreign scan via FDW.</p><h3 id="3-Summary"><a href="#3-Summary" class="headerlink" title="3. Summary"></a>3. Summary</h3><p>There is a lot of information and articals out there related to PostgreSQL’s FDW API interface. This blog is merely a quick summary of what I have learned during the FDW evaluation and there is much more to what’s discussed here. For more detail, you can refer to the official documentation about the FDW callback functons <a href="https://www.postgresql.org/docs/current/fdw-callbacks.html">here</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h3&gt;&lt;p&gt;Recently I have been</summary>
      
    
    
    
    <category term="PostgreSQL" scheme="http://caryhuang.github.io/categories/PostgreSQL/"/>
    
    
    <category term="postgresql" scheme="http://caryhuang.github.io/tags/postgresql/"/>
    
    <category term="fdw" scheme="http://caryhuang.github.io/tags/fdw/"/>
    
  </entry>
  
</feed>
