<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cary&#39;s Blog</title>
  
  
  <link href="http://caryhuang.github.io/atom.xml" rel="self"/>
  
  <link href="http://caryhuang.github.io/"/>
  <updated>2022-06-10T19:19:55.718Z</updated>
  <id>http://caryhuang.github.io/</id>
  
  <author>
    <name>Cary Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Understand PG&#39;s MVCC Visibility Check Rules</title>
    <link href="http://caryhuang.github.io/2022/06/10/Understand-PG-s-MVCC-Visibility-Check-Rules/"/>
    <id>http://caryhuang.github.io/2022/06/10/Understand-PG-s-MVCC-Visibility-Check-Rules/</id>
    <published>2022-06-10T18:13:40.000Z</published>
    <updated>2022-06-10T19:19:55.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>PostgreSQL’s MultiVersion Concurrency Control (MVCC) is an “advanced technique for improving database performance in a multi-user environment” according  to Vadim Mikheev. This technique requires multiple “versions” of the same data tuple exist in the system governed by snapshots taken during different time periods. In other words, under such technique, it is PG’s responsibility to figure out how many tuples are <code>visible</code> to the user and how many are not, according to multiple parameters such as snapshots taken, current transaction ID…etc. This is also known as <code>visibility check</code> rules in PG and today in this blog, I will talk about the basic principles of visibility check so you get an idea how PG performs this task internally and I hope it would be helpful in your development work.</p><h3 id="2-Parameters-Involved"><a href="#2-Parameters-Involved" class="headerlink" title="2. Parameters Involved?"></a>2. Parameters Involved?</h3><ul><li>The tuple itself, which contains:<ul><li>xmin (the transaction ID that inserts this tuple)</li><li>xmax (the transaction ID that deletes this tuple if &gt; 0, otherwise it’s not deleted)</li><li>cid (command ID)</li><li>hintbit </li></ul></li><li>Global top transaction ID if available </li><li>current snapshot, which also contains xmin, xmax and cid</li><li>Commit Log Data (CLOG)</li></ul><h3 id="3-The-Process"><a href="#3-The-Process" class="headerlink" title="3. The Process"></a>3. The Process</h3><h4 id="3-1-Check-the-Hintbit"><a href="#3-1-Check-the-Hintbit" class="headerlink" title="3.1 Check the Hintbit"></a>3.1 Check the Hintbit</h4><p>The visibility process starts by checking the hintbit. If hintbit has a state of <code>COMMITTED</code>, then we can skip most of the other visibility checking rules for better efficiency. With the tuple committed, PG then take this tuple’s xmin value to check with the current snapshot to ensure this tuple is not currently <code>in progress</code>. (See 3.3 below for formula to determine <code>in progress</code>). This check is required because there is a chance that this tuple, though committed, is still being updated by other backend processes at this very moment. If the tuple is not currently <code>in progress</code> by other backends, it will finally check its <code>xmax</code> value to ensure that it is invalid. Invalid means it has not been deleted. When all of the above are true, this tuple is considered visible.</p><p>If hintbit indicates <code>ABORTED</code>, then this tuple is considered invisible to user. If hintbit has no value, then PG should continue with the rest of visibility check rules.</p><h4 id="3-2-Check-If-Tuple’s-xmin-Equal-to-Global-Top-Transaction-ID"><a href="#3-2-Check-If-Tuple’s-xmin-Equal-to-Global-Top-Transaction-ID" class="headerlink" title="3.2 Check If Tuple’s xmin Equal to Global Top Transaction ID"></a>3.2 Check If Tuple’s xmin Equal to Global Top Transaction ID</h4><p>The next check involves taking tuple’s xmin and compare with global top transaction ID to see if they are equal. This global top transaction ID will only be set when user starts the transaction manually with <code>begin</code> clause. If user does not starts the transaction this way (no <code>begin</code> clause is issued), then this global top transaction ID will not be set and therefore this checking will be skipped. </p><p>If tuple xmin equals global top transaction ID, this means the tuple is currently <code>in progress</code> by the current backend, not others. This is where the command ID (cid) will be used to determine the visibility. Within a transaction block, each command issued has an associated command ID to indicate what command comes first and what comes later. For example, if a SELECT comes after an UPDATE, within a transaction, then the SELECT must see the new tuple updated by the previous UPDATE clause and cid plays a part in this determination. This behavior is also governed by the <code>isolation level</code> which is unfortunately out of scope of this blog. The default isolation level is <code>READ COMMITTED</code>, which makes the SELECT sees the data changed by previous UPDATE; but if the isolation is set to <code>REPEATABLE READ</code> then the SELECT will not see the data changed by previous UPDATE. Please keep this in mind.</p><p>If tuple’s xmin does not equal to global top transaction ID, then PG should continue with the rest of visibility</p><h4 id="3-3-Check-the-Current-Snapshot"><a href="#3-3-Check-the-Current-Snapshot" class="headerlink" title="3.3 Check the Current Snapshot"></a>3.3 Check the Current Snapshot</h4><p>The next check involves the PG to check if this tuple is currently <code>in progress</code> by other backend processes. This is done by comparing the tuple’s xmin value against current snapshot’s xmin and xmax values according to this formula.</p><ul><li>tuple xmin &lt; snapshot xmin = not in progress</li><li>tuple xmin &gt;= snapshot xmax = in progress</li></ul><p>If this tuple is considered <code>in progress</code> by the snapshot, then this tuple must not be visible to the current user because other backends are still working on it. If this tuple is NOT considered <code>in progress</code>, then PG should continue with the rest of visibility check rules.</p><h4 id="3-4-Check-the-Commit-Log-CLOG"><a href="#3-4-Check-the-Commit-Log-CLOG" class="headerlink" title="3.4 Check the Commit Log (CLOG)"></a>3.4 Check the Commit Log (CLOG)</h4><p>This next check involves the PG to take tuple’s xmin to check against the CLOG to see if this tuple has been committed or aborted. CLOG is like an array of transaction IDs and each array element stores a commit status. PG has a formula to convert a transaction ID into a CLOG block plus an offset to precisely access the right CLOG element. This CLOG data structure is regularly flushed to disk with checkpoint process and it is located in these 3 directories: <code>pg_xact</code>, <code>pg_multixact</code> and <code>pg_subtrans</code>. </p><p>If CLOG says the given tuple is committed, then PG will continue to check the tuple’s <code>xmax</code> value to ensure that it is invalid. Invalid means it has not been deleted and therefore it is visible to user. At the same time, PG will also update the hintbit value of this tuple to <code>COMMITTED</code> such that in the next visibility checking, PG will not access CLOG again, which is rather expensive. </p><p>If CLOG says the given tuple is aborted or invalid, then this tuple is not visible to the current user. At the same time, it will also update the hintbit value of this tuple to <code>INVALID</code> </p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>The above processes are the very basic visibility rules within PG according to my understanding. Of course there are other complex checking not mentioned here, such as the involvement of sub transactions and multi transactions, but they do follow somewhat similar pattern to what’s mentioned today. I hope this blog would be helpful for you.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h3&gt;&lt;p&gt;PostgreSQL’s MultiVe</summary>
      
    
    
    
    
    <category term="Postgresql" scheme="http://caryhuang.github.io/tags/Postgresql/"/>
    
    <category term="mvcc" scheme="http://caryhuang.github.io/tags/mvcc/"/>
    
    <category term="visibility check" scheme="http://caryhuang.github.io/tags/visibility-check/"/>
    
  </entry>
  
</feed>
